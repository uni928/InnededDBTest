<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>IndexedDB KV サンプル（putData / getData）</title>
  <style>
    body{font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, sans-serif; line-height:1.6; margin:2rem;}
    .card{max-width:820px; border:1px solid #ddd; border-radius:12px; padding:16px; box-shadow:0 2px 8px rgba(0,0,0,.06)}
    label{display:block; font-size:.9rem; color:#333; margin:.25rem 0 .25rem}
    input, textarea{width:100%; box-sizing:border-box; padding:.6rem .7rem; border:1px solid #ccc; border-radius:8px; font-family:inherit;}
    textarea{min-height:120px}
    .row{display:flex; gap:.75rem; margin-top:.75rem; flex-wrap:wrap}
    button{padding:.6rem 1rem; border-radius:999px; border:1px solid #ddd; background:#fff; cursor:pointer}
    button.primary{background:#111; color:#fff; border-color:#111}
    .muted{color:#666; font-size:.9rem}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
    .output{white-space:pre-wrap; background:#f7f7f7; border:1px dashed #ccc; padding:10px; border-radius:8px;}
  </style>
</head>
<body>
  <h1>IndexedDB KV サンプル</h1>
  <p class="muted">シンプルな <span class="mono">putData(key, value)</span> / <span class="mono">getData(key)</span> を提供します。DB名やStore名は決め打ちです。</p>

  <div class="card">
    <label>Key</label>
    <input id="keyInput" placeholder="例：greeting" />

    <label>Value（JSON可。自動で JSON.parse を試行・失敗時は文字列として保存）</label>
    <textarea id="valueInput" placeholder='例："こんにちは" または {"name":"Ichiro","score":99}'></textarea>

    <div class="row">
      <button class="primary" id="saveBtn">putData で保存</button>
      <button id="loadBtn">getData で取得</button>
      <button id="delBtn">deleteData で削除</button>
      <button id="dumpBtn">全キー一覧</button>
    </div>

    <h3>出力</h3>
    <div id="out" class="output">操作結果がここに表示されます。</div>
  </div>

  <script>
// ======== 設定（決め打ち） ========
const DB_NAME = 'AppKVDB';        // DB名（固定）
const DB_VERSION = 1;             // スキーマ更新時に上げる
const STORE_NAME = 'kv';          // オブジェクトストア名（固定）

// 暗号化設定（デモ用：固定パスフレーズ & ソルト）
const PASSPHRASE = 'AppKVDB#FixedKey#2025-09';       // 決め打ちの暗号化キー（パスフレーズ）
const SALT_STR   = 'AppKVDB::kv::salt-v1';           // 決め打ちソルト（変更すると復号不可に注意）
const PBKDF2_ITERATIONS = 150_000;                   // 反復回数（体感バランス用）
const AES_KEY_LENGTH = 256;                          // 256-bit AES
const GCM_IV_BYTES = 12;                             // AES-GCM の推奨 IV 長

// ======== 基本ユーティリティ ========
function ensureSupport(){
  if(!('indexedDB' in window)) throw new Error('このブラウザは IndexedDB をサポートしていません。');
  if(!window.crypto?.subtle)  throw new Error('このブラウザは WebCrypto(SubtleCrypto) をサポートしていません。');
}

function openDB(){
  ensureSupport();
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = () => {
      const db = req.result;
      if(!db.objectStoreNames.contains(STORE_NAME)){
        db.createObjectStore(STORE_NAME, { keyPath: 'key' });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
    req.onblocked = () => console.warn('DB更新がブロックされています。古いタブを閉じてください');
  });
}

// 取引(tx)の完了/失敗をPromise化
function awaitTx(tx, db){
  return new Promise((resolve, reject) => {
    tx.oncomplete = () => { try{ db && db.close(); } catch{} resolve(); };
    tx.onerror    = () => { try{ db && db.close(); } catch{} reject(tx.error); };
    tx.onabort    = () => { try{ db && db.close(); } catch{} reject(tx.error || new Error('Transaction aborted')); };
  });
}

// ======== base64 ヘルパ ========
function bufToB64(buf){
  const bytes = new Uint8Array(buf);
  let bin = '';
  for(let i=0;i<bytes.length;i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}
function b64ToBuf(b64){
  const bin = atob(b64);
  const bytes = new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
  return bytes.buffer;
}

// ======== キー導出（PBKDF2 -> AES-GCM） ========
let _cachedAesKey = null;
async function getAesKey(){
  if(_cachedAesKey) return _cachedAesKey;
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    'raw', enc.encode(PASSPHRASE), 'PBKDF2', false, ['deriveKey']
  );
  _cachedAesKey = await crypto.subtle.deriveKey(
    { name:'PBKDF2', salt: enc.encode(SALT_STR), iterations: PBKDF2_ITERATIONS, hash:'SHA-256' },
    keyMaterial,
    { name:'AES-GCM', length: AES_KEY_LENGTH },
    false,
    ['encrypt','decrypt']
  );
  return _cachedAesKey;
}

// ======== 暗号化 / 復号 ========
async function encryptValue(value){
  // value を JSON 文字列にシリアライズして暗号化
  const key = await getAesKey();
  const iv = crypto.getRandomValues(new Uint8Array(GCM_IV_BYTES));
  const enc = new TextEncoder();
  const plaintext = enc.encode(JSON.stringify(value));
  const ciphertext = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, key, plaintext);
  return {
    alg: 'AES-GCM',
    iv_b64: bufToB64(iv.buffer),
    data_b64: bufToB64(ciphertext),
  };
}

async function decryptValue(record){
  // 平文フォーマット（後方互換）：{ key, value, updatedAt }
  if (record && 'value' in record && !('data_b64' in record)) {
    return record.value;
  }
  // 暗号フォーマット：{ key, alg, iv_b64, data_b64, updatedAt }
  if (!record || !record.data_b64 || !record.iv_b64) return undefined;
  const key = await getAesKey();
  const iv  = new Uint8Array(b64ToBuf(record.iv_b64));
  const data= b64ToBuf(record.data_b64);
  const decrypted = await crypto.subtle.decrypt({ name:'AES-GCM', iv }, key, data);
  const dec = new TextDecoder();
  return JSON.parse(dec.decode(new Uint8Array(decrypted)));
}

// ======== 公開API（暗号化対応） ========
async function putData(key, value){
  if (typeof key !== 'string' || !key) {
    throw new Error('key は非空の文字列で指定してください');
  }

  // 1) 先に重い処理（暗号化など）を済ませる
  const sealed = await encryptValue(value);

  // 2) それからトランザクションを開始し、すぐにリクエストを発行
  const db = await openDB();
  const tx = db.transaction(STORE_NAME, 'readwrite');
  tx.objectStore(STORE_NAME).put({ key, ...sealed, updatedAt: new Date().toISOString() });

  // 3) トランザクション完了を待つ
  await awaitTx(tx, db);
}

async function getData(key){
  if(typeof key !== 'string' || !key) throw new Error('key は非空の文字列で指定してください');
  const db = await openDB();
  const tx = db.transaction(STORE_NAME, 'readonly');
  const store = tx.objectStore(STORE_NAME);
  const req = store.get(key);
  const record = await new Promise((resolve, reject) => {
    req.onsuccess = () => resolve(req.result || undefined);
    req.onerror = () => reject(req.error);
  });
  db.close();
  if(record === undefined) return undefined;
  return await decryptValue(record);
}

async function deleteData(key){
  const db = await openDB();
  const tx = db.transaction(STORE_NAME, 'readwrite');
  tx.objectStore(STORE_NAME).delete(key);
  await awaitTx(tx, db);
}

async function getAllKeys(){
  const db = await openDB();
  const tx = db.transaction(STORE_NAME, 'readonly');
  const store = tx.objectStore(STORE_NAME);
  const req = store.getAllKeys();
  const keys = await new Promise((resolve, reject) => {
    req.onsuccess = () => resolve(req.result || []);
    req.onerror   = () => reject(req.error);
  });
  db.close();
  return keys;
}

// グローバル公開
window.putData = putData;
window.getData = getData;
window.deleteData = deleteData;
window.getAllKeys = getAllKeys;


    // ======== デモUI ========
    const $ = (sel) => document.querySelector(sel);
    const out = (msg) => { document.getElementById('out').textContent = String(msg); };

    document.getElementById('saveBtn').addEventListener('click', async () => {
      const key = document.getElementById('keyInput').value.trim();
      let raw = document.getElementById('valueInput').value.trim();
      let value;
      if(!raw){ out('値が空です'); return; }
      try{ value = JSON.parse(raw); }
      catch{ value = raw; }
      try{
        await putData(key, value);
        out(`保存しました\nkey: ${key}\nvalue: ${JSON.stringify(value, null, 2)}`);
      }catch(e){ out('保存に失敗: ' + (e && e.message || e)); }
    });

    document.getElementById('loadBtn').addEventListener('click', async () => {
      const key = document.getElementById('keyInput').value.trim();
      try{
        const v = await getData(key);
        out(v === undefined ? `key: ${key} は未登録です` : `取得しました\nkey: ${key}\nvalue: ${JSON.stringify(v, null, 2)}`);
      }catch(e){ out('取得に失敗: ' + (e && e.message || e)); }
    });

    document.getElementById('delBtn').addEventListener('click', async () => {
      const key = document.getElementById('keyInput').value.trim();
      try{ await deleteData(key); out(`削除しました\nkey: ${key}`); }
      catch(e){ out('削除に失敗: ' + (e && e.message || e)); }
    });

    document.getElementById('dumpBtn').addEventListener('click', async () => {
      try{
        const keys = await getAllKeys();
        out('全キー:\n' + keys.join('\n'));
      }catch(e){ out('一覧取得に失敗: ' + (e && e.message || e)); }
    });

    // 起動時にサンプル値を書いてみる（重複時は上書き）
    (async () => {
      try{ await putData('example', { hello: 'world' }); }
      catch(e){ console.warn('初期書き込みでエラー:', e); }
    })();
  </script>
</body>
</html>
